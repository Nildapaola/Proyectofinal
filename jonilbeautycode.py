# -*- coding: utf-8 -*-
"""JonilBeautyCode.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aZFdlU4lvxiAMIhpbf97BWo3QTf5uoo2
"""

#pip install pandas

import pandas as pd  # Importamos Panda
import streamlit as st  # Importamos Streamlit
import os  # Esta biblioteca proporciona una interfaz para interactuar con el sistema operativo
from PIL import Image  # Biblioteca para trabajar con imágenes

# Con formato de Markdown centramos y agrandamos la letra del título de la web en Streamlit
st.markdown("<h1 style='text-align: center;'>Jonil BeautyCode</h1>", unsafe_allow_html=True)

# Nombramos al archivo de la imagen de labiales
imagen_labiales = "labiales.jpeg"
imagen_team_JONIL = "team JONIL.jpeg"

# Agregamos el texto que describe el proyecto Jonil en Streamlit
texto = """
Desde el Laboratorio del curso de Pensamiento Computacional para las comunicaciones
de la Facultad de Ciencias y Artes de la Comunicación (Z 104), se lanzó la iniciativa
de crear un proyecto a partir de la polarización en los comentarios de diversos
productos de maquillaje que aparecen en el Ecommerce de Amazon.

Este sitio web ha implementado un sistema de recomendación de productos
personalizado para una plataforma de comercio electrónico (AMAZON).
Este sistema analiza la puntuación del producto, su precio, y las reseñas de
los clientes disponibles en la misma página web para generar
una recomendación precisa que beneficie al cliente. De esta forma el proyecto optimiza el
impacto de las comunicaciones de marketing en la satisfacción y la fidelidad del cliente.
"""

# Definimos el tipo de tipografía deseada ('Arial, sans-serif')
tipografia = "Arial, sans-serif"

# Definimos el tamaño , justificación y color de la fuente (el estilo)
estilo_personalizado = f"""
    <div style="font-family: {tipografia}; font-size: 20px; text-align: justify;">
        {texto}
    </div>
"""

# Mostramos el texto con la tipografía personalizada
st.markdown(estilo_personalizado, unsafe_allow_html=True)

# Mostramos la imagen de los labiales
st.image(imagen_labiales, caption="Productos del Ecommerce", use_column_width=True)

# Función para cargar los datos desde el archivo Excel
def cargar_datos_excel(archivo_excel):
    try:
        datos = pd.read_excel(archivo_excel)
        return datos
    except Exception as e:
        st.error(f"No se pudo cargar los datos desde el archivo Excel: {e}")
        return pd.DataFrame()

# Función para filtrar y mostrar los productos de una categoría específica
def filtrar_productos_categoria(categoria, datos):
    datos = datos.dropna(subset=['Nombre'])
    productos_filtrados = datos[datos['Nombre'].str.contains(categoria, case=False, na=False)]
    return productos_filtrados

# Función para contar comentarios positivos
def contar_comentarios_positivos(comentarios, palabras_positivas):
    conteo_positivo = 0
    for palabra in palabras_positivas:
        conteo_positivo += comentarios.lower().count(palabra.lower())
    return conteo_positivo

# Función para recomendar el mejor producto basado en un criterio
def recomendar_mejor_producto(productos, criterio):
    productos['Puntuacion_Num'] = productos['Puntuacion'].str.extract(r'(\d+\.\d+)').astype(float)
    productos['Precio_Num'] = productos['Precio'].str.extract(r'(\d+\.\d+)').astype(float)
#Determinamos el tipo de palabras positivas que podrían estar presente en los comentarios
    palabras_positivas = ["love", "great", "adore", "excellent", "amazing", "fantastic"]
    productos['Comentarios_Positivos'] = productos['Comentarios'].apply(lambda x: contar_comentarios_positivos(x, palabras_positivas))

    # Normalizar los valores para combinar en el puntaje
    productos['Puntuacion_Normalizada'] = productos['Puntuacion_Num'] / productos['Puntuacion_Num'].max()
    productos['Precio_Normalizado'] = productos['Precio_Num'] / productos['Precio_Num'].max()
    productos['Comentarios_Positivos_Normalizados'] = productos['Comentarios_Positivos'] / productos['Comentarios_Positivos'].max()
  #Empezamos con las condiciones para la recomendación
    if criterio == "puntuacion":
        productos['Puntaje'] = productos['Puntuacion_Normalizada']
    elif criterio == "precio":
        productos['Puntaje'] = 1 / productos['Precio_Normalizado']  # Inverso porque queremos el menor precio
    elif criterio == "comentarios":
        productos['Puntaje'] = productos['Comentarios_Positivos_Normalizados']
    else:
        st.error("Criterio no válido.")
        return None

    # Encontrar el producto con el puntaje más alto
    mejor_producto = productos.loc[productos['Puntaje'].idxmax()]
    return mejor_producto

# Función para consolidar comentarios por producto (filtramos la base de datos)
def consolidar_comentarios(datos):
    datos_consolidados = datos.groupby('Nombre')['Comentarios'].apply(lambda x: ' | '.join(x)).reset_index()
    return datos_consolidados

# Función principal
def main():
    st.title("Buscador y Comparador de Productos")

    # Carga el archivo Excel directamente
    archivo_excel = 'BASEDATOS.xlsx'
    datos = cargar_datos_excel(archivo_excel)

    if not datos.empty:
      #Entrada de texto para la categoria de producto
        categoria_producto = st.text_input("Ingrese la categoría del producto que desea buscar: Aceite de labios o Brillo labial").lower()

        if st.button("Buscar"):
            productos_filtrados = filtrar_productos_categoria(categoria_producto, datos)

            # Consolidar comentarios por producto
            productos_consolidados = consolidar_comentarios(productos_filtrados)
            productos_filtrados = productos_filtrados.drop(columns=['Comentarios']).drop_duplicates().merge(productos_consolidados, on='Nombre')

            if not productos_filtrados.empty:
                st.session_state['productos_filtrados'] = productos_filtrados  # Guardar los productos filtrados en session_state para almacenar
            else:
                st.warning(f"No se encontraron productos para la categoría '{categoria_producto}'.")

        if 'productos_filtrados' in st.session_state and st.session_state['productos_filtrados'] is not None:
            st.write("### Recomendar Mejor Producto Según:")
            if st.button("Puntuación"):
                criterio = "puntuacion"
            elif st.button("Precio"):
                criterio = "precio"
            elif st.button("Comentarios"):
                criterio = "comentarios"
            else:
                criterio = None

            if criterio:
                mejor_producto = recomendar_mejor_producto(st.session_state['productos_filtrados'], criterio)
                if mejor_producto is not None:
                    st.write("### Mejor Opción")
                    st.write(f"**Nombre:** {mejor_producto['Nombre']}")
                    st.write(f"**Puntuación:** {mejor_producto['Puntuacion']}")
                    st.write(f"**Precio:** {mejor_producto['Precio']}")
                    st.write("**Comentarios:**")
                    comentarios = mejor_producto['Comentarios'].split(' | ')
                    for comentario in comentarios[:3]:
                        st.write(f"- {comentario}")

            st.write("### Productos Encontrados")
            for i, row in st.session_state['productos_filtrados'].iterrows():
                st.write(f"**Nombre:** {row['Nombre']}")
                st.write(f"**Puntuación:** {row['Puntuacion']}")
                st.write(f"**Precio:** {row['Precio']}")
                comentarios = row['Comentarios'].split(' | ')
                for comentario in comentarios[:3]:  # Mostrar hasta 3 comentarios
                    st.write(f"**Comentario:** {comentario}")
                st.write("---")

    else:
        st.error("No se pudo cargar los datos desde el archivo Excel.")

if __name__ == "__main__":
    main()

# Mostramos la imagen del Team JONIL
st.image(imagen_team_JONIL, caption="Equipo del Proyecto de Jonil BeautyCode", use_column_width=True)